 Path Traversal Vulnerability 
==============================================================================
Vulnerability exists when user-controllable data is used to access files & directories in an unsafe manner.
Attacker supplies crafted input which may allow him unintended read or write access to files.

# Consequences/Risk 
May allow an attacker to read or overwrite sensitive files

    Password files for OS and Application
    Server and Application Configuration files
    Include files containing database credentials
    MySQL database files or XML files
    Source code files
    Log files containing usernames or session tokens

If you get write access then, it can ultimately be used for arbitrary command execution.

    Create scripts in startup folder
    Write script in web directory & execute by calling in browser

Identifying Path Traversal attack targets in an application

1. Initial mapping of the application helps in identifying Path traversal attack targets
2. Thoroughly test the functionality where User can 

    upload or download files
    share documents
    upload images
    download ebooks, documents, manuals

3. Test any GET or POST request PARAMETER which contains a filename or directory name
4. Test application functions which may retrieve data from a server filesystem ( instead of DB)

    displaying documents
    displaying images

5. If you have local access to the application server (Whitebox test)

    Use a tool like FileMon (Win), ltrace/strace (Unix) to moniter file system activity
    Using Burp Intruder, inject a UNIQUE STRING into every user injectable parameter in the application.
    Detect the UNIQUE string injected above using a filesystem moniter tool & Identify the parameter and test it for Path Traversal Vulnerability

Detecting the existence of Path Traversal vulnerability

1. Test whether user supplied crafted input is being blocked by the application

    Try the following two as filenames

        foo.txt
        /bar/../foo.txt 

    If Application behave in the same way for both inputs, then, it MAY BE VULNERABLE

Point to be Noted: Most file systems attempt canonicalization of a filepath before they try to retrieve it, In the above case    /bar/../  cancels out ( folder /bar/ doesn't need to exist

2. To TEST If the application is vulnerable & allows READ ACCESS try the following

    ../../../../../../../../../../../etc/passwd
    ../../../../../../../../../../../windows/win.ini

3. To TEST CONCLUSIVELY, that the application is vulnerable & allows WRITE ACCESS 
Write into a file that any user can write into & then write into a file in which even root cannot write The difference in application response can be USED TO CONCLUDE THAT writing is successful

    Try the following in WINDOWS

        ../../../../../../../../../../../test.txt
        ../../../../../../../../../../../windows/system32/config/test ( will fail)

    Try the following in UNIX

        ../../../../../../../../../../../tmp/test.txt
        ../../../../../../../../../../../tmp  (will fail)

 Point to be Noted: Overwriting a directory with a file will always fail in UNIX
 Point to be Noted: All file systems ignore redundant /../ sequences, so try submitting a large number of traversal sequences,
Point to be Noted: Windows tolerates both forward and backward slashes as directory separators.
Point to be Noted: Unix only accepts forward slashes as directory separators.
Point to be Noted: Don't rely on the knowledge of OS of the app server, a backend service may be using a different OS, so try both back and forward slashes.

4. Alternative method, to TEST if WRITE ACCESS is working is to try and write a new file in webroot & open it with browser.

Circumventing Flawed Defense mechanisms 
If the mechanism used to prevent Path Traversal is flawed ==> it can be bypassed

1. If the filter attempts to sanitize the input to remove the sequences, it can be defeated with Encoding
2. Try both back & forward slashes, some filters only remove forward slash while file system may         support both. Try the following encodings for   /../

    URL encoding
    16 bit Unicode encoding
    Double URL Encoding
    Overlong UTF-8 Unicode Encoding
    Use Burp Intruder to generate "Illegal Unicode" within Burp, these may be accepted by the Unicode decoders, particularly on windows.

3. If application removes ../ but doesn't remove it RECURSIVELY from ( ....//), then the following          will work because ../ will get removed and ../ will be left behind.

    ....//
    ....\/
    ....\\
    ..../\

4. If filetype (suffix) is being verified by the application, Sometimes, it can be subverted by placing a      null byte as follows

    ../../../../boot.ini.jpg

Point to be Noted: This works because, this check is done in a Managed Environment (Java) which allows Strings to have a NULL character, but the API actually retrieves the file in an UNMANGED environment, in which Strings are NULL Terminated.

 5. If application appends the filetype suffix on its own, then also NULL byte attack can work
 6. If an application tries to verify that that the filename starts with a particular directory name              (downloads), then it can be subverted as follows

    downloads/../../../../../../../etc/passwd


# FILE INCLUDE VS DIRECTORY TRAVERSAL 
~~~
LFI : IT has ability to execute file. It may be shell code or other local file which exist in the system

Directory Traversal: It only traversal the files, so we can only read it. It can't execute files. This is type of Sensitive Information Disclosure 
~~~

# Prevention
# Use a Content Management System
~~~
If your site handles a lot of documents, chances are the workflows around uploading, indexing, publishing, and replacing documents will be quite involved. You may have non-technical users acting as administrators. If this is the case, look into using a third-party content management system, which are designed for exactly these cases.

A modern CMS will protect against directory traversal.
~~~
# Use Indirection
~~~
If a content-management system proves too heavyweight as a solution, consider using indirection to label your files. Each time a file is uploaded, construct a “friendly” name for this on your site, and when the file is accessed, perform a lookup in your data-store to discover the actual file path.

This approach effectively white-lists valid names, and avoids the fragility of passing around raw file paths.
~~~
# Segregate Your Documents
~~~
Hosting documents on a separate file-server or file partition, or in cloud storage, is a good idea too. This will allow you to prevent mixing public documents and more sensitive material.
Sanitize Filename Parameters

If you insist on using raw file names, you need to sanitize the file names coming in from HTTP requests. Initially, this would seem to be simply a matter of checking for “back-tracking” paths starting with ../.

In actual fact, it is a lot more complex than that. For example, Unix file systems interpret paths starting ~/ as relative to the home directory. It is even easier to construct a lot of ambiguous paths in Windows. Moreover, depending on how URLs are encoded, it is possible to obscure malicious paths. See here for a list of exploits people have found.

The safest approach is to restrict filenames to a list of known good characters, and ensure that any references to files use only those characters.
~~~
# Run with Restricted Permissions
~~~
It is a good practice to run your server processes with only the permissions that they require to function – the principle of least privilege. This can help limit the impact of vulnerabilities as a second line of defense.

Make sure the server process can only access the directories it needs. Consider running the process in a chroot jail if you are running on Unix. This will mitigate the risks if a directory traversal vulnerability is discovered.
~~~

In case where file upload & download functionality is required & user needs to specify the filename. Take all the following steps
~~~
    Perform decoding & canonicalization of user input.
    Check if the filename contains backslash (\), forwardslash(/) , null bytes, if yes, then stop processing
    Hard code the list of permissible filetypes and reject any request for a different file type.
    Now, use file system API (Eg. getCanonicalPath) to verify that, the file PATH specified is actually the same as the PATH allowed by the application, and only then allow access to the file. 
    Java - Java.io.File.getCanonicalPath ,                                                                         
    ASP.NET - System.io.Path.GetFullPath
~~~
