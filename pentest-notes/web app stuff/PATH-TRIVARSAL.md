 Path Traversal Vulnerability
==============================================================================
Vulnerability exists when user-controllable data is used to access files & directories in an unsafe manner.
Attacker supplies crafted input which may allow him unintended read or write access to files.

Consequences/Risk : May allow an attacker to read or overwrite sensitive files

    Password files for OS and Application
    Server and Application Configuration files
    Include files containing database credentials
    MySQL database files or XML files
    Source code files
    Log files containing usernames or session tokens

If you get write access then, it can ultimately be used for arbitrary command execution.

    Create scripts in startup folder
    Write script in web directory & execute by calling in browser

Preventing Path Traversal Vulnerability

Most effective Technique 

    Avoid passing user submitted data to filesystem API.
    Files which do not need to be access controlled can be placed in webroot & accessed via URL.

If it is unavoidable to take filename as a parameter then

    Maintain a mapping of fileName to fileID
    Allow files to be accessed using FileID only. There is no attack surface in technique.

In case where file upload & download functionality is required & user needs to specify the filename. Take all the following steps

    Perform decoding & canonicalization of user input.
    Check if the filename contains backslash (\), forwardslash(/) , null bytes, if yes, then stop processing
    Hard code the list of permissible filetypes and reject any request for a different file type.
    Now, use file system API (Eg. getCanonicalPath) to verify that, the file PATH specified is actually the same as the PATH allowed by the application, and only then allow access to the file. 
    Java - Java.io.File.getCanonicalPath ,                                                                         
    ASP.NET - System.io.Path.GetFullPath

Use a chrooted environment to mitigate the impact of path traversal vulnerabilites

    Chrooted directory - is treated as filesystem root
    Any attempt to access a directory above it using /../  sequence is ignored.
    On Windows - mount a directory as new logical drive & access it using the associated drive letter. It will not allow access to higher directories using /../ sequence.

Identifying Path Traversal attack targets in an application

1. Initial mapping of the application helps in identifying Path traversal attack targets
2. Thoroughly test the functionality where User can 

    upload or download files
    share documents
    upload images
    download ebooks, documents, manuals

3. Test any GET or POST request PARAMETER which contains a filename or directory name
4. Test application functions which may retrieve data from a server filesystem ( instead of DB)

    displaying documents
    displaying images

5. If you have local access to the application server (Whitebox test)

    Use a tool like FileMon (Win), ltrace/strace (Unix) to moniter file system activity
    Using Burp Intruder, inject a UNIQUE STRING into every user injectable parameter in the application.
    Detect the UNIQUE string injected above using a filesystem moniter tool & Identify the parameter and test it for Path Traversal Vulnerability

Detecting the existence of Path Traversal vulnerability

1. Test whether user supplied crafted input is being blocked by the application

    Try the following two as filenames

        foo.txt
        /bar/../foo.txt 

    If Application behave in the same way for both inputs, then, it MAY BE VULNERABLE

Point to be Noted: Most file systems attempt canonicalization of a filepath before they try to retrieve it, In the above case    /bar/../  cancels out ( folder /bar/ doesn't need to exist

2. To TEST If the application is vulnerable & allows READ ACCESS try the following

    ../../../../../../../../../../../etc/passwd
    ../../../../../../../../../../../windows/win.ini

3. To TEST CONCLUSIVELY, that the application is vulnerable & allows WRITE ACCESS 
Write into a file that any user can write into & then write into a file in which even root cannot write The difference in application response can be USED TO CONCLUDE THAT writing is successful

    Try the following in WINDOWS

        ../../../../../../../../../../../test.txt
        ../../../../../../../../../../../windows/system32/config/test ( will fail)

    Try the following in UNIX

        ../../../../../../../../../../../tmp/test.txt
        ../../../../../../../../../../../tmp  (will fail)

 Point to be Noted: Overwriting a directory with a file will always fail in UNIX
 Point to be Noted: All file systems ignore redundant /../ sequences, so try submitting a large number of traversal sequences,
Point to be Noted: Windows tolerates both forward and backward slashes as directory separators.
Point to be Noted: Unix only accepts forward slashes as directory separators.
Point to be Noted: Don't rely on the knowledge of OS of the app server, a backend service may be using a different OS, so try both back and forward slashes.

4. Alternative method, to TEST if WRITE ACCESS is working is to try and write a new file in webroot & open it with browser.

Circumventing Flawed Defense mechanisms 
If the mechanism used to prevent Path Traversal is flawed ==> it can be bypassed

1. If the filter attempts to sanitize the input to remove the sequences, it can be defeated with Encoding
2. Try both back & forward slashes, some filters only remove forward slash while file system may         support both. Try the following encodings for   /../

    URL encoding
    16 bit Unicode encoding
    Double URL Encoding
    Overlong UTF-8 Unicode Encoding
    Use Burp Intruder to generate "Illegal Unicode" within Burp, these may be accepted by the Unicode decoders, particularly on windows.

3. If application removes ../ but doesn't remove it RECURSIVELY from ( ....//), then the following          will work because ../ will get removed and ../ will be left behind.

    ....//
    ....\/
    ....\\
    ..../\

4. If filetype (suffix) is being verified by the application, Sometimes, it can be subverted by placing a      null byte as follows

    ../../../../boot.ini.jpg

Point to be Noted: This works because, this check is done in a Managed Environment (Java) which allows Strings to have a NULL character, but the API actually retrieves the file in an UNMANGED environment, in which Strings are NULL Terminated.

 5. If application appends the filetype suffix on its own, then also NULL byte attack can work
 6. If an application tries to verify that that the filename starts with a particular directory name              (downloads), then it can be subverted as follows

    downloads/../../../../../../../etc/passwd


FILE INCLUDE VS DIRECTORY TRAVERSAL 
LFI : IT has ability to execute file. It may be shell code or other local file which exist in the system

Directory Traversal: It only traversal the files, so we can only read it. It can't execute files. This is type of Sensitive Information Disclosure 
