Cross-Site Scripting (XSS)

What is it?

Put simply, Cross-Site Scripting allows an attacker to execute script(s) in a victim’s browser. This can be used to hijack user sessions (by getting cookies, session ID’s and so on), alter the contents of a web page or redirect a user to an evil site. There are two common types:

    Stored XSS: this is when an injected script is stored on the server in a fixed location. The classic example is a forum post, where every user which requests the post from the server will subsequently be affected by the XSS attack. Also referred to as Persistent or Type-I XSS. For this reason, it is usually classified as the most severe since it will typically impact the highest number of users.
    Reflected XSS: this is when an injected script within a request is reflected back in the server’s response. A common example is a search feature which responds by printing (or reflecting) the user’s malicious search input as well as outputting the search information. Given this format, a reflected XSS attack must involve targeting a victim through another method such as social engineering in order to get them to send the request which elicits a reflected response. Also referred to as non-persistent or Type-II XSS.

There is also a third, lesser-known XSS attack vector:

    DOM-based XSS: as the name suggests, this type of XSS differs from the other two types in that it appears in the DOM (Document Object Model) rather than the HTML document. This means that the latter is not modified, and so the payload will not be found in the server’s response — it can instead be identified by investigating the DOM of the page. A trivial DOM-based XSS payload could look like this:

http://www.example.com/test.html#<script>alert(1)</script>
When Does it Happen?

We’ll break this down by the different XSS types, since they can have different causes:

    Stored & Reflected XSS: the web app or API stores user input which is unsanitised, unescaped, unvalidated or fails to be encoded.
    DOM-based XSS: JavaScript frameworks, single-page applications and APIs which dynamically include user-inputted data are vulnerable to this type of attack.
    
Impact of XSS:

XSS can lead to t
he following
1.steal credentials in non HTTPOnly cookies.
2.send requests to a server with the user's credentials. 
3.steal secrets that are stored in JS variables.
4.prompt the user to download content by submitting a form
5.display text that seems to come from the site owners. (Phishing)
6.display a password input, log keystrokes, and send the result to a site of your choosing
7.redirect to another site
8.get GPS/camera data if the user has granted that site access to the device

How to Mitigate Cross-Site Scripting Attacks

OWASP have a couple of excellent XSS prevention cheat sheets: one for reflected/stored attacks, and another for DOM-based attacks. The main steps to enforce are:

    Employ a combination of validating, filtering, encoding and escaping methods to prevent untrusted user input from executing on the web app. The first OWASP cheat sheet listed above goes into extended detail about methods you can use to prevent malicious input executing as intended.
    Move to frameworks which automatically escape XSS by design (recent Ruby on Rails version, React JS).
    Enforce secure headers (such as X-XSS-Protection: 1; mode=block and Content-Security-Policy).
